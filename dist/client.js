"use strict";
/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.13.0 (NJsonSchema v9.10.50.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
Object.defineProperty(exports, "__esModule", { value: true });
class Client {
    constructor(baseUrl, transformOptions, http) {
        this.jsonParseReviver = undefined;
        this.http = http ? http : window;
        this.transformOptions = transformOptions;
        this.baseUrl = baseUrl ? baseUrl : "https://api.matchmore.io/v5";
    }
    /**
     * Create a device
     * @device The device to be created.
     * @return Representation of the newly created device.
     */
    createDevice(device) {
        let url_ = this.baseUrl + "/devices";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(device);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreateDevice(_response);
        });
    }
    processCreateDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201 || status === 200) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Device.fromJS(resultData201) : new Device();
                return result201;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : _responseText;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get IBeacons triples for all registered devices
     * @return Expected response to a valid request.
     */
    getIBeaconTriples() {
        let url_ = this.baseUrl + "/devices/IBeaconTriples";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetIBeaconTriples(_response);
        });
    }
    processGetIBeaconTriples(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(IBeaconTriple.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Info about a device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getDevice(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetDevice(_response);
        });
    }
    processGetDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Device.fromJS(resultData200) : new Device();
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Delete an existing device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    deleteDevice(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processDeleteDevice(_response);
        });
    }
    processDeleteDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Updates name or/and device token for existing device
     * @deviceId The id (UUID) of the device.
     * @device The device update description.
     * @return Expected response to a valid request.
     */
    updateDevice(deviceId, device) {
        let url_ = this.baseUrl + "/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(device);
        let options_ = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processUpdateDevice(_response);
        });
    }
    processUpdateDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Device.fromJS(resultData200) : new Device();
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get matches for the device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getMatches(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/matches";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetMatches(_response);
        });
    }
    processGetMatches(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Match.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get match for the device by its id
     * @deviceId The id (UUID) of the user device.
     * @matchId The id (UUID) of the match.
     * @return Expected response to a valid request.
     */
    getMatch(deviceId, matchId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/matches/{matchId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (matchId === undefined || matchId === null)
            throw new Error("The parameter 'matchId' must be defined.");
        url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetMatch(_response);
        });
    }
    processGetMatch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Match.fromJS(resultData200) : new Match();
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 ? Match.fromJS(resultData404) : new Match();
                return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Create a publication for a device
     * @deviceId The id (UUID) of the device.
     * @publication Publication to create on a device.
     * @return The representation of the newly created publication.
     */
    createPublication(deviceId, publication) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(publication);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreatePublication(_response);
        });
    }
    processCreatePublication(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? Publication.fromJS(resultData201)
                    : new Publication();
                return result201;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get all publications for a device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getPublications(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetPublications(_response);
        });
    }
    processGetPublications(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Publication.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Info about a publication on a device
     * @deviceId The id (UUID) of the device.
     * @publicationId The id (UUID) of the publication.
     * @return Expected response to a valid request.
     */
    getPublication(deviceId, publicationId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications/{publicationId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (publicationId === undefined || publicationId === null)
            throw new Error("The parameter 'publicationId' must be defined.");
        url_ = url_.replace("{publicationId}", encodeURIComponent("" + publicationId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetPublication(_response);
        });
    }
    processGetPublication(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200
                    ? Publication.fromJS(resultData200)
                    : new Publication();
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Delete a Publication
     * @deviceId The id (UUID) of the device.
     * @publicationId The id (UUID) of the subscription.
     * @return Expected response to a valid request.
     */
    deletePublication(deviceId, publicationId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications/{publicationId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (publicationId === undefined || publicationId === null)
            throw new Error("The parameter 'publicationId' must be defined.");
        url_ = url_.replace("{publicationId}", encodeURIComponent("" + publicationId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processDeletePublication(_response);
        });
    }
    processDeletePublication(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Create a subscription for a device
     * @deviceId The id (UUID) of the device.
     * @subscription Subscription to create on a device.
     * @return Expected response to a valid request.
     */
    createSubscription(deviceId, subscription) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(subscription);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreateSubscription(_response);
        });
    }
    processCreateSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? Subscription.fromJS(resultData201)
                    : new Subscription();
                return result201;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get all subscriptions for a device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getSubscriptions(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetSubscriptions(_response);
        });
    }
    processGetSubscriptions(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Subscription.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Info about a subscription on a device
     * @deviceId The id (UUID) of the device.
     * @subscriptionId The id (UUID) of the subscription.
     * @return Expected response to a valid request.
     */
    getSubscription(deviceId, subscriptionId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions/{subscriptionId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetSubscription(_response);
        });
    }
    processGetSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200
                    ? Subscription.fromJS(resultData200)
                    : new Subscription();
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Delete a Subscription
     * @deviceId The id (UUID) of the device.
     * @subscriptionId The id (UUID) of the subscription.
     * @return Expected response to a valid request.
     */
    deleteSubscription(deviceId, subscriptionId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions/{subscriptionId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processDeleteSubscription(_response);
        });
    }
    processDeleteSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Create a new location for a device
     * @deviceId The id (UUID) of the device.
     * @location Location to create for a device.
     * @return Expected response to a valid request.
     */
    createLocation(deviceId, location) {
        let url_ = this.baseUrl + "/devices/{deviceId}/locations";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(location);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreateLocation(_response);
        });
    }
    processCreateLocation(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? Location.fromJS(resultData201)
                    : new Location();
                return result201;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Trigger the proximity event between a device and a ranged BLE iBeacon
     * @deviceId The id (UUID) of the device.
     * @proximityEvent The proximity event to be created for the device.
     * @return Representation of the newly created proximity event for the device.
     */
    triggerProximityEvents(deviceId, proximityEvent) {
        let url_ = this.baseUrl + "/devices/{deviceId}/proximityEvents";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(proximityEvent);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processTriggerProximityEvents(_response);
        });
    }
    processTriggerProximityEvents(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? ProximityEvent.fromJS(resultData201)
                    : new ProximityEvent();
                return result201;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
}
exports.Client = Client;
/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
var DeviceType;
(function (DeviceType) {
    DeviceType[DeviceType["MobileDevice"] = "MobileDevice"] = "MobileDevice";
    DeviceType[DeviceType["PinDevice"] = "PinDevice"] = "PinDevice";
    DeviceType[DeviceType["IBeaconDevice"] = "IBeaconDevice"] = "IBeaconDevice";
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
class Device {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.name = "";
        }
        this._discriminator = "Device";
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.updatedAt = data["updatedAt"];
            if (data["group"] && data["group"].constructor === Array) {
                this.group = [];
                for (let item of data["group"])
                    this.group.push(item);
            }
            this.name = data["name"] !== undefined ? data["name"] : "";
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        if (data["deviceType"] === "MobileDevice") {
            let result = new MobileDevice();
            result.init(data);
            return result;
        }
        if (data["deviceType"] === "PinDevice") {
            let result = new PinDevice();
            result.init(data);
            return result;
        }
        if (data["deviceType"] === "IBeaconDevice") {
            let result = new IBeaconDevice();
            result.init(data);
            return result;
        }
        let result = new Device();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["deviceType"] = this._discriminator;
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        if (this.group && this.group.constructor === Array) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        data["name"] = this.name;
        return data;
    }
}
exports.Device = Device;
/** Describes update of device, it allows to change name of device and device token (only in case of mobile devices) */
class DeviceUpdate {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.name = data["name"];
            this.deviceToken = data["deviceToken"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new DeviceUpdate();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["deviceToken"] = this.deviceToken;
        return data;
    }
}
exports.DeviceUpdate = DeviceUpdate;
class IBeaconTriple {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.proximityUUID = data["proximityUUID"];
            this.major = data["major"];
            this.minor = data["minor"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new IBeaconTriple();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["deviceId"] = this.deviceId;
        data["proximityUUID"] = this.proximityUUID;
        data["major"] = this.major;
        data["minor"] = this.minor;
        return data;
    }
}
exports.IBeaconTriple = IBeaconTriple;
class Location {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.latitude = 0;
            this.longitude = 0;
            this.altitude = 0;
            this.horizontalAccuracy = 1;
            this.verticalAccuracy = 1;
        }
    }
    init(data) {
        if (data) {
            this.createdAt = data["createdAt"];
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : 0;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : 0;
            this.altitude = data["altitude"] !== undefined ? data["altitude"] : 0;
            this.horizontalAccuracy =
                data["horizontalAccuracy"] !== undefined
                    ? data["horizontalAccuracy"]
                    : 1;
            this.verticalAccuracy =
                data["verticalAccuracy"] !== undefined ? data["verticalAccuracy"] : 1;
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["createdAt"] = this.createdAt;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["altitude"] = this.altitude;
        data["horizontalAccuracy"] = this.horizontalAccuracy;
        data["verticalAccuracy"] = this.verticalAccuracy;
        return data;
    }
}
exports.Location = Location;
/** A publication can be seen as a JavaMessagingService (JMS) publication extended with the notion of a geographical zone. The zone is defined as circle with a center at the given location and a range around that location. */
class Publication {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.worldId = data["worldId"];
            this.deviceId = data["deviceId"];
            this.topic = data["topic"];
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : undefined;
            this.range = data["range"];
            this.duration = data["duration"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key]
                            ? Anonymous.fromJS(data["properties"][key])
                            : undefined;
                }
            }
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Publication();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["worldId"] = this.worldId;
        data["deviceId"] = this.deviceId;
        data["topic"] = this.topic;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        data["range"] = this.range;
        data["duration"] = this.duration;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data;
    }
}
exports.Publication = Publication;
/** A subscription can be seen as a JMS subscription extended with the notion of geographical zone. The zone again being defined as circle with a center at the given location and a range around that location. */
class Subscription {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.worldId = data["worldId"];
            this.deviceId = data["deviceId"];
            this.topic = data["topic"];
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : undefined;
            this.selector = data["selector"];
            this.range = data["range"];
            this.duration = data["duration"];
            this.matchTTL = data["matchTTL"];
            if (data["pushers"] && data["pushers"].constructor === Array) {
                this.pushers = [];
                for (let item of data["pushers"])
                    this.pushers.push(item);
            }
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["worldId"] = this.worldId;
        data["deviceId"] = this.deviceId;
        data["topic"] = this.topic;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        data["selector"] = this.selector;
        data["range"] = this.range;
        data["duration"] = this.duration;
        data["matchTTL"] = this.matchTTL;
        if (this.pushers && this.pushers.constructor === Array) {
            data["pushers"] = [];
            for (let item of this.pushers)
                data["pushers"].push(item);
        }
        return data;
    }
}
exports.Subscription = Subscription;
/** An object representing a match between a subscription and a publication. */
class Match {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.publication = new Publication();
            this.subscription = new Subscription();
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.publication = data["publication"]
                ? Publication.fromJS(data["publication"])
                : new Publication();
            this.subscription = data["subscription"]
                ? Subscription.fromJS(data["subscription"])
                : new Subscription();
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Match();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["publication"] = this.publication
            ? this.publication.toJSON()
            : undefined;
        data["subscription"] = this.subscription
            ? this.subscription.toJSON()
            : undefined;
        return data;
    }
}
exports.Match = Match;
class APIError {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new APIError();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}
exports.APIError = APIError;
/** A mobile device is one that potentially moves together with its user and therefore has a geographical location associated with it. */
class MobileDevice extends Device {
    constructor(data) {
        super(data);
        if (!data) {
            this.location = new Location();
        }
        this._discriminator = "MobileDevice";
    }
    init(data) {
        super.init(data);
        if (data) {
            this.platform = data["platform"];
            this.deviceToken = data["deviceToken"];
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : new Location();
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new MobileDevice();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["platform"] = this.platform;
        data["deviceToken"] = this.deviceToken;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
exports.MobileDevice = MobileDevice;
/** A pin device is one that has geographical location associated with it but is not represented by any object in the physical world. */
class PinDevice extends Device {
    constructor(data) {
        super(data);
        if (!data) {
            this.location = new Location();
        }
        this._discriminator = "PinDevice";
    }
    init(data) {
        super.init(data);
        if (data) {
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : new Location();
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new PinDevice();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["location"] = this.location ? this.location.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
exports.PinDevice = PinDevice;
/** An iBeacon device represents an Apple conform iBeacon announcing its presence via Bluetooth advertising packets. */
class IBeaconDevice extends Device {
    constructor(data) {
        super(data);
        this._discriminator = "IBeaconDevice";
    }
    init(data) {
        super.init(data);
        if (data) {
            this.proximityUUID = data["proximityUUID"];
            this.major = data["major"];
            this.minor = data["minor"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new IBeaconDevice();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["proximityUUID"] = this.proximityUUID;
        data["major"] = this.major;
        data["minor"] = this.minor;
        super.toJSON(data);
        return data;
    }
}
exports.IBeaconDevice = IBeaconDevice;
/** A proximity event is triggered to the core when a mobile device detects an iBeacon device in his Bluetooth Low Energy(BLE) range. */
class ProximityEvent {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.deviceId = data["deviceId"];
            this.distance = data["distance"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new ProximityEvent();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["deviceId"] = this.deviceId;
        data["distance"] = this.distance;
        return data;
    }
}
exports.ProximityEvent = ProximityEvent;
class Anonymous {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        return data;
    }
}
exports.Anonymous = Anonymous;
class SwaggerException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isSwaggerException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isSwaggerException(obj) {
        return obj.isSwaggerException === true;
    }
}
exports.SwaggerException = SwaggerException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}
