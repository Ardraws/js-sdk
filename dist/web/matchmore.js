(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.matchmore = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.13.0 (NJsonSchema v9.10.50.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
Object.defineProperty(exports, "__esModule", { value: true });
class Client {
    constructor(baseUrl, transformOptions, http) {
        this.jsonParseReviver = undefined;
        this.http = http ? http : window;
        this.transformOptions = transformOptions;
        this.baseUrl = baseUrl ? baseUrl : "https://api.matchmore.io/v5";
    }
    /**
     * Create a device
     * @device The device to be created.
     * @return Representation of the newly created device.
     */
    createDevice(device) {
        let url_ = this.baseUrl + "/devices";
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(device);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreateDevice(_response);
        });
    }
    processCreateDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201 || status === 200) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Device.fromJS(resultData201) : new Device();
                return result201;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : _responseText;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get IBeacons triples for all registered devices
     * @return Expected response to a valid request.
     */
    getIBeaconTriples() {
        let url_ = this.baseUrl + "/devices/IBeaconTriples";
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetIBeaconTriples(_response);
        });
    }
    processGetIBeaconTriples(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(IBeaconTriple.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Info about a device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getDevice(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetDevice(_response);
        });
    }
    processGetDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Device.fromJS(resultData200) : new Device();
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Delete an existing device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    deleteDevice(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processDeleteDevice(_response);
        });
    }
    processDeleteDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Updates name or/and device token for existing device
     * @deviceId The id (UUID) of the device.
     * @device The device update description.
     * @return Expected response to a valid request.
     */
    updateDevice(deviceId, device) {
        let url_ = this.baseUrl + "/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(device);
        let options_ = {
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processUpdateDevice(_response);
        });
    }
    processUpdateDevice(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Device.fromJS(resultData200) : new Device();
                return result200;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get matches for the device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getMatches(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/matches";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetMatches(_response);
        });
    }
    processGetMatches(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Match.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get match for the device by its id
     * @deviceId The id (UUID) of the user device.
     * @matchId The id (UUID) of the match.
     * @return Expected response to a valid request.
     */
    getMatch(deviceId, matchId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/matches/{matchId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (matchId === undefined || matchId === null)
            throw new Error("The parameter 'matchId' must be defined.");
        url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetMatch(_response);
        });
    }
    processGetMatch(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Match.fromJS(resultData200) : new Match();
                return result200;
            });
        }
        else if (status === 404) {
            return response.text().then(_responseText => {
                let result404 = null;
                let resultData404 = _responseText === ""
                    ? null
                    : _responseText;
                return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Create a publication for a device
     * @deviceId The id (UUID) of the device.
     * @publication Publication to create on a device.
     * @return The representation of the newly created publication.
     */
    createPublication(deviceId, publication) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(publication);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreatePublication(_response);
        });
    }
    processCreatePublication(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? Publication.fromJS(resultData201)
                    : new Publication();
                return result201;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get all publications for a device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getPublications(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetPublications(_response);
        });
    }
    processGetPublications(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Publication.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Info about a publication on a device
     * @deviceId The id (UUID) of the device.
     * @publicationId The id (UUID) of the publication.
     * @return Expected response to a valid request.
     */
    getPublication(deviceId, publicationId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications/{publicationId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (publicationId === undefined || publicationId === null)
            throw new Error("The parameter 'publicationId' must be defined.");
        url_ = url_.replace("{publicationId}", encodeURIComponent("" + publicationId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetPublication(_response);
        });
    }
    processGetPublication(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200
                    ? Publication.fromJS(resultData200)
                    : new Publication();
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Delete a Publication
     * @deviceId The id (UUID) of the device.
     * @publicationId The id (UUID) of the subscription.
     * @return Expected response to a valid request.
     */
    deletePublication(deviceId, publicationId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/publications/{publicationId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (publicationId === undefined || publicationId === null)
            throw new Error("The parameter 'publicationId' must be defined.");
        url_ = url_.replace("{publicationId}", encodeURIComponent("" + publicationId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processDeletePublication(_response);
        });
    }
    processDeletePublication(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Create a subscription for a device
     * @deviceId The id (UUID) of the device.
     * @subscription Subscription to create on a device.
     * @return Expected response to a valid request.
     */
    createSubscription(deviceId, subscription) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(subscription);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreateSubscription(_response);
        });
    }
    processCreateSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? Subscription.fromJS(resultData201)
                    : new Subscription();
                return result201;
            });
        }
        else if (status === 403) {
            return response.text().then(_responseText => {
                return throwException("A server error occurred.", status, _responseText, _headers);
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Get all subscriptions for a device
     * @deviceId The id (UUID) of the device.
     * @return Expected response to a valid request.
     */
    getSubscriptions(deviceId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetSubscriptions(_response);
        });
    }
    processGetSubscriptions(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Subscription.fromJS(item));
                }
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Info about a subscription on a device
     * @deviceId The id (UUID) of the device.
     * @subscriptionId The id (UUID) of the subscription.
     * @return Expected response to a valid request.
     */
    getSubscription(deviceId, subscriptionId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions/{subscriptionId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processGetSubscription(_response);
        });
    }
    processGetSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200 = null;
                let resultData200 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200
                    ? Subscription.fromJS(resultData200)
                    : new Subscription();
                return result200;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Delete a Subscription
     * @deviceId The id (UUID) of the device.
     * @subscriptionId The id (UUID) of the subscription.
     * @return Expected response to a valid request.
     */
    deleteSubscription(deviceId, subscriptionId) {
        let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions/{subscriptionId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        if (subscriptionId === undefined || subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' must be defined.");
        url_ = url_.replace("{subscriptionId}", encodeURIComponent("" + subscriptionId));
        url_ = url_.replace(/[?&]$/, "");
        let options_ = {
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processDeleteSubscription(_response);
        });
    }
    processDeleteSubscription(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Create a new location for a device
     * @deviceId The id (UUID) of the device.
     * @location Location to create for a device.
     * @return Expected response to a valid request.
     */
    createLocation(deviceId, location) {
        let url_ = this.baseUrl + "/devices/{deviceId}/locations";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(location);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processCreateLocation(_response);
        });
    }
    processCreateLocation(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? Location.fromJS(resultData201)
                    : new Location();
                return result201;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
    /**
     * Trigger the proximity event between a device and a ranged BLE iBeacon
     * @deviceId The id (UUID) of the device.
     * @proximityEvent The proximity event to be created for the device.
     * @return Representation of the newly created proximity event for the device.
     */
    triggerProximityEvents(deviceId, proximityEvent) {
        let url_ = this.baseUrl + "/devices/{deviceId}/proximityEvents";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");
        const content_ = JSON.stringify(proximityEvent);
        let options_ = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };
        return this.transformOptions(options_)
            .then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        })
            .then((_response) => {
            return this.processTriggerProximityEvents(_response);
        });
    }
    processTriggerProximityEvents(response) {
        const status = response.status;
        let _headers = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v, k) => (_headers[k] = v));
        }
        if (status === 201) {
            return response.text().then(_responseText => {
                let result201 = null;
                let resultData201 = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201
                    ? ProximityEvent.fromJS(resultData201)
                    : new ProximityEvent();
                return result201;
            });
        }
        else {
            return response.text().then(_responseText => {
                let result = null;
                let resultData = _responseText === ""
                    ? null
                    : JSON.parse(_responseText, this.jsonParseReviver);
                result = resultData ? APIError.fromJS(resultData) : null;
                return throwException("A server error occurred.", status, _responseText, _headers, result);
            });
        }
    }
}
exports.Client = Client;
/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
var DeviceType;
(function (DeviceType) {
    DeviceType[DeviceType["MobileDevice"] = "MobileDevice"] = "MobileDevice";
    DeviceType[DeviceType["PinDevice"] = "PinDevice"] = "PinDevice";
    DeviceType[DeviceType["IBeaconDevice"] = "IBeaconDevice"] = "IBeaconDevice";
})(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
class Device {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.name = "";
        }
        this._discriminator = "Device";
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.updatedAt = data["updatedAt"];
            if (data["group"] && data["group"].constructor === Array) {
                this.group = [];
                for (let item of data["group"])
                    this.group.push(item);
            }
            this.name = data["name"] !== undefined ? data["name"] : "";
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        if (data["deviceType"] === "MobileDevice") {
            let result = new MobileDevice();
            result.init(data);
            return result;
        }
        if (data["deviceType"] === "PinDevice") {
            let result = new PinDevice();
            result.init(data);
            return result;
        }
        if (data["deviceType"] === "IBeaconDevice") {
            let result = new IBeaconDevice();
            result.init(data);
            return result;
        }
        let result = new Device();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["deviceType"] = this._discriminator;
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["updatedAt"] = this.updatedAt;
        if (this.group && this.group.constructor === Array) {
            data["group"] = [];
            for (let item of this.group)
                data["group"].push(item);
        }
        data["name"] = this.name;
        return data;
    }
}
exports.Device = Device;
/** Describes update of device, it allows to change name of device and device token (only in case of mobile devices) */
class DeviceUpdate {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.name = data["name"];
            this.deviceToken = data["deviceToken"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new DeviceUpdate();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["name"] = this.name;
        data["deviceToken"] = this.deviceToken;
        return data;
    }
}
exports.DeviceUpdate = DeviceUpdate;
class IBeaconTriple {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.deviceId = data["deviceId"];
            this.proximityUUID = data["proximityUUID"];
            this.major = data["major"];
            this.minor = data["minor"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new IBeaconTriple();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["deviceId"] = this.deviceId;
        data["proximityUUID"] = this.proximityUUID;
        data["major"] = this.major;
        data["minor"] = this.minor;
        return data;
    }
}
exports.IBeaconTriple = IBeaconTriple;
class Location {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.latitude = 0;
            this.longitude = 0;
            this.altitude = 0;
            this.horizontalAccuracy = 1;
            this.verticalAccuracy = 1;
        }
    }
    init(data) {
        if (data) {
            this.createdAt = data["createdAt"];
            this.latitude = data["latitude"] !== undefined ? data["latitude"] : 0;
            this.longitude = data["longitude"] !== undefined ? data["longitude"] : 0;
            this.altitude = data["altitude"] !== undefined ? data["altitude"] : 0;
            this.horizontalAccuracy =
                data["horizontalAccuracy"] !== undefined
                    ? data["horizontalAccuracy"]
                    : 1;
            this.verticalAccuracy =
                data["verticalAccuracy"] !== undefined ? data["verticalAccuracy"] : 1;
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["createdAt"] = this.createdAt;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["altitude"] = this.altitude;
        data["horizontalAccuracy"] = this.horizontalAccuracy;
        data["verticalAccuracy"] = this.verticalAccuracy;
        return data;
    }
}
exports.Location = Location;
/** A publication can be seen as a JavaMessagingService (JMS) publication extended with the notion of a geographical zone. The zone is defined as circle with a center at the given location and a range around that location. */
class Publication {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.properties = {};
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.worldId = data["worldId"];
            this.deviceId = data["deviceId"];
            this.topic = data["topic"];
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : undefined;
            this.range = data["range"];
            this.duration = data["duration"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key]
                            ? data["properties"][key]
                            : undefined;
                }
            }
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Publication();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["worldId"] = this.worldId;
        data["deviceId"] = this.deviceId;
        data["topic"] = this.topic;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        data["range"] = this.range;
        data["duration"] = this.duration;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data;
    }
}
exports.Publication = Publication;
/** A subscription can be seen as a JMS subscription extended with the notion of geographical zone. The zone again being defined as circle with a center at the given location and a range around that location. */
class Subscription {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.worldId = data["worldId"];
            this.deviceId = data["deviceId"];
            this.topic = data["topic"];
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : undefined;
            this.selector = data["selector"];
            this.range = data["range"];
            this.duration = data["duration"];
            this.matchTTL = data["matchTTL"];
            if (data["pushers"] && data["pushers"].constructor === Array) {
                this.pushers = [];
                for (let item of data["pushers"])
                    this.pushers.push(item);
            }
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Subscription();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["worldId"] = this.worldId;
        data["deviceId"] = this.deviceId;
        data["topic"] = this.topic;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        data["selector"] = this.selector;
        data["range"] = this.range;
        data["duration"] = this.duration;
        data["matchTTL"] = this.matchTTL;
        if (this.pushers && this.pushers.constructor === Array) {
            data["pushers"] = [];
            for (let item of this.pushers)
                data["pushers"].push(item);
        }
        return data;
    }
}
exports.Subscription = Subscription;
/** An object representing a match between a subscription and a publication. */
class Match {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
        if (!data) {
            this.publication = new Publication();
            this.subscription = new Subscription();
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.publication = data["publication"]
                ? Publication.fromJS(data["publication"])
                : new Publication();
            this.subscription = data["subscription"]
                ? Subscription.fromJS(data["subscription"])
                : new Subscription();
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new Match();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["publication"] = this.publication
            ? this.publication.toJSON()
            : undefined;
        data["subscription"] = this.subscription
            ? this.subscription.toJSON()
            : undefined;
        return data;
    }
}
exports.Match = Match;
class APIError {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new APIError();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data;
    }
}
exports.APIError = APIError;
/** A mobile device is one that potentially moves together with its user and therefore has a geographical location associated with it. */
class MobileDevice extends Device {
    constructor(data) {
        super(data);
        if (!data) {
            this.location = new Location();
        }
        this._discriminator = "MobileDevice";
    }
    init(data) {
        super.init(data);
        if (data) {
            this.platform = data["platform"];
            this.deviceToken = data["deviceToken"];
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : new Location();
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new MobileDevice();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["platform"] = this.platform;
        data["deviceToken"] = this.deviceToken;
        data["location"] = this.location ? this.location.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
exports.MobileDevice = MobileDevice;
/** A pin device is one that has geographical location associated with it but is not represented by any object in the physical world. */
class PinDevice extends Device {
    constructor(data) {
        super(data);
        if (!data) {
            this.location = new Location();
        }
        this._discriminator = "PinDevice";
    }
    init(data) {
        super.init(data);
        if (data) {
            this.location = data["location"]
                ? Location.fromJS(data["location"])
                : new Location();
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new PinDevice();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["location"] = this.location ? this.location.toJSON() : undefined;
        super.toJSON(data);
        return data;
    }
}
exports.PinDevice = PinDevice;
/** An iBeacon device represents an Apple conform iBeacon announcing its presence via Bluetooth advertising packets. */
class IBeaconDevice extends Device {
    constructor(data) {
        super(data);
        this._discriminator = "IBeaconDevice";
    }
    init(data) {
        super.init(data);
        if (data) {
            this.proximityUUID = data["proximityUUID"];
            this.major = data["major"];
            this.minor = data["minor"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new IBeaconDevice();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["proximityUUID"] = this.proximityUUID;
        data["major"] = this.major;
        data["minor"] = this.minor;
        super.toJSON(data);
        return data;
    }
}
exports.IBeaconDevice = IBeaconDevice;
/** A proximity event is triggered to the core when a mobile device detects an iBeacon device in his Bluetooth Low Energy(BLE) range. */
class ProximityEvent {
    constructor(data) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    this[property] = data[property];
            }
        }
    }
    init(data) {
        if (data) {
            this.id = data["id"];
            this.createdAt = data["createdAt"];
            this.deviceId = data["deviceId"];
            this.distance = data["distance"];
        }
    }
    static fromJS(data) {
        data = typeof data === "object" ? data : {};
        let result = new ProximityEvent();
        result.init(data);
        return result;
    }
    toJSON(data) {
        data = typeof data === "object" ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt;
        data["deviceId"] = this.deviceId;
        data["distance"] = this.distance;
        return data;
    }
}
exports.ProximityEvent = ProximityEvent;
class SwaggerException extends Error {
    constructor(message, status, response, headers, result) {
        super();
        this.isSwaggerException = true;
        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }
    static isSwaggerException(obj) {
        return obj.isSwaggerException === true;
    }
}
exports.SwaggerException = SwaggerException;
function throwException(message, status, response, headers, result) {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

},{}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const manager_1 = require("./manager");
exports.Manager = manager_1.Manager;
const client_1 = require("./client");
exports.Client = client_1.Client;
const InMemoryPersistenceManager_1 = require("./persistences/InMemoryPersistenceManager");
exports.InMemoryPersistenceManager = InMemoryPersistenceManager_1.default;
const LocalStoragePersistenceManager_1 = require("./persistences/LocalStoragePersistenceManager");
exports.LocalStoragePersistenceManager = LocalStoragePersistenceManager_1.default;
const platform_1 = require("./platform");
exports.PlatformConfig = platform_1.default;
const matchmonitor_1 = require("./matchmonitor");
exports.MatchMonitorMode = matchmonitor_1.MatchMonitorMode;

},{"./client":1,"./manager":4,"./matchmonitor":5,"./persistences/InMemoryPersistenceManager":7,"./persistences/LocalStoragePersistenceManager":8,"./platform":9}],3:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("./client");
class LocationManager {
    constructor(manager, config) {
        this.manager = manager;
        this._defaultConfig = {
            enableHighAccuracy: false,
            timeout: 60000,
            maximumAge: 60000
        };
        this.onLocationReceived = (loc) => __awaiter(this, void 0, void 0, function* () {
            const location = new client_1.Location({
                latitude: loc.coords.latitude,
                longitude: loc.coords.longitude,
                altitude: loc.coords.altitude || 0,
                horizontalAccuracy: loc.coords.accuracy,
                verticalAccuracy: loc.coords.accuracy
            });
            yield this.manager.updateLocation(location);
            if (this._onLocationUpdate) {
                this._onLocationUpdate(location);
            }
        });
        this._gpsConfig = config || this._defaultConfig;
        this._onLocationUpdate = _ => { };
    }
    startUpdatingLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(this.onLocationReceived, this.onError, this._gpsConfig);
            this._geoId = navigator.geolocation.watchPosition(this.onLocationReceived, this.onError, this._gpsConfig);
        }
        else {
            throw new Error("Geolocation is not supported in this browser/app");
        }
    }
    stopUpdatingLocation() {
        if (navigator.geolocation) {
            navigator.geolocation.clearWatch(this._geoId);
        }
        else {
            throw new Error("Geolocation is not supported in this browser/app");
        }
    }
    set onLocationUpdate(onLocationUpdate) {
        this._onLocationUpdate = onLocationUpdate;
    }
    onError(error) {
        throw new Error(error.message);
        // switch (error.code) {
        //   case error.PERMISSION_DENIED:
        //     throw new Error("User denied the request for Geolocation.");
        //   case error.POSITION_UNAVAILABLE:
        //     throw new Error("Location information is unavailable.");
        //   case error.TIMEOUT:
        //     throw new Error("The request to get user location timed out. " );
        //   case error.UNKNOWN_ERROR:
        //     throw new Error("An unknown error occurred.");
        // }
    }
}
exports.LocationManager = LocationManager;

},{"./client":1}],4:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("./client");
const Base64 = require("Base64");
const matchmonitor_1 = require("./matchmonitor");
const locationmanager_1 = require("./locationmanager");
const index_1 = require("./index");
class Manager {
    constructor(apiKey, apiUrlOverride, persistenceManager, gpsConfig) {
        this.apiKey = apiKey;
        this.apiUrlOverride = apiUrlOverride;
        if (!apiKey)
            throw new Error("Api key required");
        this._persistenceManager =
            persistenceManager || new index_1.InMemoryPersistenceManager();
        this.token = JSON.parse(Base64.atob(this.apiKey.split(".")[1])); // as Token;
        // this.defaultClient.authentications["api-key"].apiKey = this.apiKey;
        // Hack the api location (to use an overidden value if needed)
        var basePath = "https://api.matchmore.io/v5";
        if (this.apiUrlOverride)
            basePath = this.apiUrlOverride;
        else
            this.apiUrlOverride = basePath;
        this.api = new client_1.Client(basePath, options => {
            options.headers["api-key"] = this.apiKey;
            return Promise.resolve(options);
        }, {
            fetch
        });
        this._matchMonitor = new matchmonitor_1.MatchMonitor(this);
        this._locationManager = new locationmanager_1.LocationManager(this, gpsConfig);
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._persistenceManager.load();
        });
    }
    get apiUrl() {
        return this.apiUrlOverride;
    }
    get defaultDevice() {
        return this._persistenceManager.defaultDevice();
    }
    get devices() {
        return this._persistenceManager.devices();
    }
    get publications() {
        return this._persistenceManager.publications();
    }
    get subscriptions() {
        return this._persistenceManager.subscriptions();
    }
    /**
     * Creates a mobile device
     * @param name
     * @param platform
     * @param deviceToken platform token for push notifications for example apns://apns-token or fcm://fcm-token
     */
    createMobileDevice(name, platform, deviceToken) {
        return this.createAnyDevice(new client_1.MobileDevice({
            name: name,
            platform: platform,
            deviceToken: deviceToken,
            location: new client_1.Location({ latitude: 0, longitude: 0, altitude: 0 })
        }));
    }
    /**
     * Create a pin device
     * @param name
     * @param location
     */
    createPinDevice(name, location) {
        return this.createAnyDevice(new client_1.PinDevice({
            name: name,
            location: this.resolveLocationType(location)
        }));
    }
    /**
     * Creates an ibeacon device
     * @param name
     * @param proximityUUID
     * @param major
     * @param minor
     */
    createIBeaconDevice(name, proximityUUID, major, minor) {
        return this.createAnyDevice(new client_1.IBeaconDevice({
            name: name,
            proximityUUID: proximityUUID,
            major: major,
            minor: minor
        }));
    }
    /**
     * Create a device
     * @param device whole device object
     */
    createAnyDevice(device) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.api.createDevice(device);
                const ddevice = this._persistenceManager.defaultDevice();
                const isDefault = !ddevice;
                this._persistenceManager.addDevice(result, isDefault);
                return result;
            }
            catch (error) {
                this.handleError(error, `create device '${device.name}'`);
            }
        });
    }
    handleError(error, operation) {
        if (error instanceof client_1.SwaggerException) {
            throw new Error(`An error has occurred during '${operation}': ${error} ${error.status}, ${error.response}`);
        }
        throw error;
    }
    /**
     * Deletes device
     * @param deviceId
     */
    deleteDevice(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.api.deleteDevice(deviceId);
                const d = this._persistenceManager.devices().find(d => d.id == deviceId);
                if (d)
                    this._persistenceManager.remove(d);
                return;
            }
            catch (error) {
                this.handleError(error, `delete device '${deviceId}'`);
            }
        });
    }
    /**
     * Create a publication for a device
     * @param topic topic of the publication
     * @param range range in meters
     * @param duration time in seconds
     * @param properties properties on which the sub selector can filter on
     * @param deviceId optional, if not provided the default device will be used
     */
    createPublication(topic, range, duration, properties, deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                const publication = new client_1.Publication({
                    worldId: this.token.sub,
                    topic: topic,
                    deviceId: deviceWithId,
                    range: range,
                    duration: duration,
                    properties: properties
                });
                const result = yield this.api.createPublication(deviceWithId, publication);
                this._persistenceManager.add(result);
                return result;
            }
            catch (error) {
                this.handleError(error, `create publication for topic ${topic}`);
            }
        });
    }
    /**
     * Delete a publication for specified device
     * @param deviceId
     * @param pubId
     */
    deletePublication(deviceId, pubId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.api.deletePublication(deviceId, pubId);
                const d = this._persistenceManager
                    .publications()
                    .find(d => d.id == pubId);
                if (d)
                    this._persistenceManager.remove(d);
            }
            catch (error) {
                this.handleError(error, `delete publication for device ${deviceId}, publication ${pubId}`);
            }
        });
    }
    /**
     * Create a subscription for a device
     * @param topic topic of the subscription
     * @param range range in meters
     * @param duration time in seconds
     * @param selector selector which is used for filtering publications
     * @param deviceId optional, if not provided the default device will be used
     */
    createSubscription(topic, range, duration, selector, deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                const subscription = new client_1.Subscription({
                    worldId: this.token.sub,
                    topic: topic,
                    deviceId: deviceWithId,
                    range: range,
                    duration: duration,
                    selector: selector || ""
                });
                const result = yield this.api.createSubscription(deviceWithId, subscription);
                this._persistenceManager.add(result);
                return result;
            }
            catch (error) {
                this.handleError(error, `create subscription for topic ${topic}`);
            }
        });
    }
    deleteSubscription(deviceId, subId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.api.deleteSubscription(deviceId, subId);
                const d = this._persistenceManager
                    .publications()
                    .find(d => d.id == subId);
                if (d)
                    this._persistenceManager.remove(d);
                return result;
            }
            catch (error) {
                this.handleError(error, `delete subscription for device ${deviceId}, subscription ${subId}`);
            }
        });
    }
    /**
     * Updates the device location
     * @param location
     * @param deviceId optional, if not provided the default device will be used
     */
    updateLocation(location, deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                yield this.api.createLocation(deviceWithId, this.resolveLocationType(location));
            }
            catch (error) {
                this.handleError(error, `creating location ['${location.latitude}'`);
            }
        });
    }
    resolveLocationType(location) {
        if (!this.isLocation(location))
            this.badLocation(location);
        return new client_1.Location({
            altitude: location.altitude || 0,
            latitude: location.latitude,
            longitude: location.longitude
        });
    }
    badLocation(location) {
        let str = "";
        try {
            str = JSON.stringify(location);
        }
        catch (_a) { }
        throw new Error(`Location ${str} was invalid`);
    }
    isLocation(obj) {
        return (obj.longitude !== undefined &&
            obj.latitude !== undefined);
    }
    /**
     * Returns all current matches
     * @param deviceId optional, if not provided the default device will be used
     */
    getAllMatches(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                const result = yield this.api.getMatches(deviceWithId);
                return result;
            }
            catch (error) {
                this.handleError(error, `fetch matches`);
            }
        });
    }
    /**
     * Returns a specific match for device
     * @param deviceId optional, if not provided the default device will be used
     */
    getMatch(matchId, deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                const result = yield this.api.getMatch(deviceWithId, matchId);
                return result;
            }
            catch (error) {
                this.handleError(error, `fetch match ${matchId}`);
            }
        });
    }
    /**
     * Gets publications
     * @param deviceId optional, if not provided the default device will be used
     */
    getAllPublications(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                const result = yield this.api.getPublications(deviceWithId);
                return result;
            }
            catch (error) {
                this.handleError(error, `fetch publications`);
            }
        });
    }
    deviceWithId(deviceId) {
        if (!!deviceId) {
            return deviceId;
        }
        if (!!this.defaultDevice && !!this.defaultDevice.id) {
            return this.defaultDevice.id;
        }
        throw new Error("There is no default device available and no other device id was supplied,  please call createDevice before thi call or provide a device id");
    }
    /**
     * Gets subscriptions
     * @param deviceId optional, if not provided the default device will be used
     */
    getAllSubscriptions(deviceId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const deviceWithId = this.deviceWithId(deviceId);
                const result = yield this.api.getSubscriptions(deviceWithId);
                return result;
            }
            catch (error) {
                this.handleError(error, `fetch subscriptions`);
            }
        });
    }
    /**
     * Registers a callback for matches
     * @param completion
     */
    set onMatch(completion) {
        this._matchMonitor.onMatch = completion;
    }
    /**
     * Register a callback for location updates
     * @param completion
     */
    set onLocationUpdate(completion) {
        this._locationManager.onLocationUpdate = completion;
    }
    startMonitoringMatches(mode) {
        this._matchMonitor.startMonitoringMatches(mode);
    }
    stopMonitoringMatches() {
        this._matchMonitor.stopMonitoringMatches();
    }
    startUpdatingLocation() {
        this._locationManager.startUpdatingLocation();
    }
    stopUpdatingLocation() {
        this._locationManager.stopUpdatingLocation();
    }
}
exports.Manager = Manager;

},{"./client":1,"./index":2,"./locationmanager":3,"./matchmonitor":5,"Base64":10}],5:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const WebSocket = require("universal-websocket-client");
var MatchMonitorMode;
(function (MatchMonitorMode) {
    MatchMonitorMode[MatchMonitorMode["polling"] = 0] = "polling";
    MatchMonitorMode[MatchMonitorMode["websocket"] = 1] = "websocket";
})(MatchMonitorMode = exports.MatchMonitorMode || (exports.MatchMonitorMode = {}));
class MatchMonitor {
    constructor(manager) {
        this.manager = manager;
        this._deliveredMatches = [];
        this._onMatch = (match) => { };
    }
    set onMatch(onMatch) {
        this._onMatch = onMatch;
    }
    get deliveredMatches() {
        return this._deliveredMatches;
    }
    startMonitoringMatches(mode) {
        if (!this.manager.defaultDevice)
            throw new Error("Default device not yet set!");
        if (mode === undefined || mode == MatchMonitorMode.polling) {
            this.stopMonitoringMatches();
            const timer = setInterval(() => {
                this.checkMatches();
            }, 1000);
            return;
        }
        if (mode == MatchMonitorMode.websocket) {
            const socketUrl = this.manager.apiUrl
                .replace("https://", "wss://")
                .replace("http://", "ws://")
                .replace("v5", "") +
                "pusher/v5/ws/" +
                this.manager.defaultDevice.id;
            const ws = new WebSocket(socketUrl, ["api-key", this.manager.token.sub]);
            ws.onmessage = (msg) => __awaiter(this, void 0, void 0, function* () { return yield this.checkMatch(msg.data); });
        }
    }
    stopMonitoringMatches() {
        if (this._timerId) {
            clearInterval(this._timerId);
        }
    }
    checkMatch(matchId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (matchId == "ping" || matchId == "pong")
                return;
            if (!this.manager.defaultDevice)
                return;
            if (this.hasNotBeenDelivered({ id: matchId })) {
                try {
                    const match = yield this.manager.getMatch(matchId, this.manager.defaultDevice.id);
                    this._deliveredMatches.push(match);
                    this._onMatch(match);
                }
                catch (error) {
                    console.log(error);
                }
            }
        });
    }
    checkMatches() {
        this.manager.getAllMatches().then(matches => {
            for (const idx in matches) {
                const match = matches[idx];
                if (this.hasNotBeenDelivered(match)) {
                    this._deliveredMatches.push(match);
                    this._onMatch(match);
                }
            }
        });
    }
    hasNotBeenDelivered(match) {
        for (const idx in this._deliveredMatches) {
            const deliveredMatch = this._deliveredMatches[idx];
            if (deliveredMatch.id == match.id)
                return false;
        }
        return true;
    }
}
exports.MatchMonitor = MatchMonitor;

},{"universal-websocket-client":11}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class MatchmoreEntityDiscriminator {
    static isDevice(x) {
        return (x.deviceToken !== undefined ||
            x.location !== undefined ||
            x.proximityUUID !== undefined);
    }
    static isSubscription(x) {
        return x.selector !== undefined;
    }
    static isPublication(x) {
        return x.properties !== undefined;
    }
}
exports.MatchmoreEntityDiscriminator = MatchmoreEntityDiscriminator;

},{}],7:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const persistence_1 = require("../persistence");
class InMemoryPersistenceManager {
    constructor() {
        this._devices = [];
        this._publications = [];
        this._subscriptions = [];
    }
    devices() {
        return this._devices;
    }
    publications() {
        return this._publications;
    }
    onLoad(onLoad) {
        this._onLoad = onLoad;
    }
    subscriptions() {
        return this._subscriptions;
    }
    add(entity) {
        if (persistence_1.MatchmoreEntityDiscriminator.isDevice(entity)) {
            const device = entity;
            this._devices.push(device);
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isPublication(entity)) {
            const pub = entity;
            this._publications.push(pub);
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isSubscription(entity)) {
            const sub = entity;
            this._subscriptions.push(sub);
            return;
        }
    }
    remove(entity) {
        if (persistence_1.MatchmoreEntityDiscriminator.isDevice(entity)) {
            const device = entity;
            if (device.id == this._defaultDevice.id)
                throw new Error("Cannot deconste default device");
            this._devices = this._devices.filter(d => device.id != d.id);
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isPublication(entity)) {
            const pub = entity;
            this._publications = this._publications.filter(d => pub.id != d.id);
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isSubscription(entity)) {
            const sub = entity;
            this._subscriptions = this._subscriptions.filter(d => sub.id != d.id);
            return;
        }
    }
    defaultDevice() {
        return this._defaultDevice;
    }
    addDevice(device, isDefault) {
        this.add(device);
        if (isDefault)
            this._defaultDevice = device;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            // do nothing
            return true;
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            // do nothing
            return true;
        });
    }
}
exports.default = InMemoryPersistenceManager;

},{"../persistence":6}],8:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const persistence_1 = require("../persistence");
const platform_1 = require("../platform");
const storageKey = '@matchmoreSdk:data';
class LocalStoragePersistenceManager {
    constructor() {
        this._devices = [];
        this._publications = [];
        this._subscriptions = [];
    }
    devices() {
        return this._devices;
    }
    publications() {
        return this._publications;
    }
    subscriptions() {
        return this._subscriptions;
    }
    add(entity) {
        if (persistence_1.MatchmoreEntityDiscriminator.isDevice(entity)) {
            const device = entity;
            this._devices.push(device);
            this.save();
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isPublication(entity)) {
            const pub = entity;
            this._publications.push(pub);
            this.save();
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isSubscription(entity)) {
            const sub = entity;
            this._subscriptions.push(sub);
            this.save();
            return;
        }
    }
    remove(entity) {
        if (persistence_1.MatchmoreEntityDiscriminator.isDevice(entity)) {
            const device = entity;
            if (device.id == this._defaultDevice.id)
                throw new Error("Cannot deconste default device");
            this._devices = this._devices.filter(d => device.id != d.id);
            this.save();
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isPublication(entity)) {
            const pub = entity;
            this._publications = this._publications.filter(d => pub.id != d.id);
            this.save();
            return;
        }
        if (persistence_1.MatchmoreEntityDiscriminator.isSubscription(entity)) {
            const sub = entity;
            this._subscriptions = this._subscriptions.filter(d => sub.id != d.id);
            this.save();
            return;
        }
    }
    defaultDevice() {
        return this._defaultDevice;
    }
    addDevice(device, isDefault) {
        this.add(device);
        if (isDefault)
            this._defaultDevice = device;
        this.save();
    }
    onLoad(onLoad) {
        this._onLoad = onLoad;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const dataString = yield platform_1.default.storage.load(storageKey);
            const data = JSON.parse(dataString);
            if (data) {
                this._devices = data.devices.map((deviceObject) => deviceObject);
                this._subscriptions = data.subscriptions.map((subscriptionObject) => subscriptionObject);
                this._publications = data.publications.map((publicationObject) => publicationObject);
                this._defaultDevice = data.defaultDevice;
            }
            return true;
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const saveData = {
                devices: this._devices,
                subscriptions: this._subscriptions,
                publications: this._publications,
                defaultDevice: this._defaultDevice,
            };
            return yield platform_1.default.storage.save(storageKey, JSON.stringify(saveData));
        });
    }
}
exports.default = LocalStoragePersistenceManager;

},{"../persistence":6,"../platform":9}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PlatformConfig {
    constructor() {
        this.storage = null;
        this.webSocket = null;
    }
    static getInstance() {
        if (!PlatformConfig.instance) {
            PlatformConfig.instance = new PlatformConfig();
        }
        return PlatformConfig.instance;
    }
}
exports.PlatformConfig = PlatformConfig;
const instance = PlatformConfig.getInstance();
exports.default = instance;

},{}],10:[function(require,module,exports){
;(function () {

  var object =
    typeof exports != 'undefined' ? exports :
    typeof self != 'undefined' ? self : // #8: web workers
    $.global; // #31: ExtendScript

  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    var str = String(input);
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next str index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      str.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = str.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    var str = String(input).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=
    if (str.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = str.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],11:[function(require,module,exports){
'use strict';

module.exports = WebSocket;

},{}]},{},[2])(2)
});
