/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.13.0 (NJsonSchema v9.10.50.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  private transformOptions: (RequestInit) => Promise<RequestInit>;
  protected jsonParseReviver: (key: string, value: any) => any = undefined;

  constructor(
    baseUrl?: string,
    transformOptions?: (RequestInit) => Promise<RequestInit>,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : <any>window;
    this.transformOptions = transformOptions;
    this.baseUrl = baseUrl ? baseUrl : "https://api.matchmore.io/v5";
  }

  /**
   * Create a device
   * @device The device to be created.
   * @return Representation of the newly created device.
   */
  createDevice(device: Device): Promise<Device> {
    let url_ = this.baseUrl + "/devices";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(device);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateDevice(_response);
      });
  }

  protected processCreateDevice(response: Response): Promise<Device> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201 || status === 200) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201 ? Device.fromJS(resultData201) : new Device();
        return result201;
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : _responseText;
        
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Get IBeacons triples for all registered devices
   * @return Expected response to a valid request.
   */
  getIBeaconTriples(): Promise<IBeaconTriple[]> {
    let url_ = this.baseUrl + "/devices/IBeaconTriples";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetIBeaconTriples(_response);
      });
  }

  protected processGetIBeaconTriples(
    response: Response
  ): Promise<IBeaconTriple[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(IBeaconTriple.fromJS(item));
        }
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Info about a device
   * @deviceId The id (UUID) of the device.
   * @return Expected response to a valid request.
   */
  getDevice(deviceId: string): Promise<Device> {
    let url_ = this.baseUrl + "/devices/{deviceId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetDevice(_response);
      });
  }

  protected processGetDevice(response: Response): Promise<Device> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Device.fromJS(resultData200) : new Device();
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Delete an existing device
   * @deviceId The id (UUID) of the device.
   * @return Expected response to a valid request.
   */
  deleteDevice(deviceId: string): Promise<void> {
    let url_ = this.baseUrl + "/devices/{deviceId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        "Content-Type": "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteDevice(_response);
      });
  }

  protected processDeleteDevice(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Updates name or/and device token for existing device
   * @deviceId The id (UUID) of the device.
   * @device The device update description.
   * @return Expected response to a valid request.
   */
  updateDevice(deviceId: string, device: DeviceUpdate): Promise<Device> {
    let url_ = this.baseUrl + "/devices/{deviceId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(device);

    let options_ = <RequestInit>{
      body: content_,
      method: "PATCH",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processUpdateDevice(_response);
      });
  }

  protected processUpdateDevice(response: Response): Promise<Device> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Device.fromJS(resultData200) : new Device();
        return result200;
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Get matches for the device
   * @deviceId The id (UUID) of the device.
   * @return Expected response to a valid request.
   */
  getMatches(deviceId: string): Promise<Match[]> {
    let url_ = this.baseUrl + "/devices/{deviceId}/matches";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMatches(_response);
      });
  }

  protected processGetMatches(response: Response): Promise<Match[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200) result200.push(Match.fromJS(item));
        }
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Get match for the device by its id
   * @deviceId The id (UUID) of the user device.
   * @matchId The id (UUID) of the match.
   * @return Expected response to a valid request.
   */
  getMatch(deviceId: string, matchId: string): Promise<Match> {
    let url_ = this.baseUrl + "/devices/{deviceId}/matches/{matchId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    if (matchId === undefined || matchId === null)
      throw new Error("The parameter 'matchId' must be defined.");
    url_ = url_.replace("{matchId}", encodeURIComponent("" + matchId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetMatch(_response);
      });
  }

  protected processGetMatch(response: Response): Promise<Match> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Match.fromJS(resultData200) : new Match();
        return result200;
      });
    } else if (status === 404) {
      return response.text().then(_responseText => {
        let result404: any = null;
        let resultData404 =
          _responseText === ""
            ? null
            : _responseText;
        
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result404
        );
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Create a publication for a device
   * @deviceId The id (UUID) of the device.
   * @publication Publication to create on a device.
   * @return The representation of the newly created publication.
   */
  createPublication(
    deviceId: string,
    publication: Publication
  ): Promise<Publication> {
    let url_ = this.baseUrl + "/devices/{deviceId}/publications";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(publication);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreatePublication(_response);
      });
  }

  protected processCreatePublication(response: Response): Promise<Publication> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? Publication.fromJS(resultData201)
          : new Publication();
        return result201;
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Get all publications for a device
   * @deviceId The id (UUID) of the device.
   * @return Expected response to a valid request.
   */
  getPublications(deviceId: string): Promise<Publication[]> {
    let url_ = this.baseUrl + "/devices/{deviceId}/publications";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPublications(_response);
      });
  }

  protected processGetPublications(response: Response): Promise<Publication[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(Publication.fromJS(item));
        }
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Info about a publication on a device
   * @deviceId The id (UUID) of the device.
   * @publicationId The id (UUID) of the publication.
   * @return Expected response to a valid request.
   */
  getPublication(
    deviceId: string,
    publicationId: string
  ): Promise<Publication> {
    let url_ =
      this.baseUrl + "/devices/{deviceId}/publications/{publicationId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    if (publicationId === undefined || publicationId === null)
      throw new Error("The parameter 'publicationId' must be defined.");
    url_ = url_.replace(
      "{publicationId}",
      encodeURIComponent("" + publicationId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetPublication(_response);
      });
  }

  protected processGetPublication(response: Response): Promise<Publication> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? Publication.fromJS(resultData200)
          : new Publication();
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Delete a Publication
   * @deviceId The id (UUID) of the device.
   * @publicationId The id (UUID) of the subscription.
   * @return Expected response to a valid request.
   */
  deletePublication(deviceId: string, publicationId: string): Promise<void> {
    let url_ =
      this.baseUrl + "/devices/{deviceId}/publications/{publicationId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    if (publicationId === undefined || publicationId === null)
      throw new Error("The parameter 'publicationId' must be defined.");
    url_ = url_.replace(
      "{publicationId}",
      encodeURIComponent("" + publicationId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        "Content-Type": "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeletePublication(_response);
      });
  }

  protected processDeletePublication(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Create a subscription for a device
   * @deviceId The id (UUID) of the device.
   * @subscription Subscription to create on a device.
   * @return Expected response to a valid request.
   */
  createSubscription(
    deviceId: string,
    subscription: Subscription
  ): Promise<Subscription> {
    let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(subscription);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateSubscription(_response);
      });
  }

  protected processCreateSubscription(
    response: Response
  ): Promise<Subscription> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? Subscription.fromJS(resultData201)
          : new Subscription();
        return result201;
      });
    } else if (status === 403) {
      return response.text().then(_responseText => {
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Get all subscriptions for a device
   * @deviceId The id (UUID) of the device.
   * @return Expected response to a valid request.
   */
  getSubscriptions(deviceId: string): Promise<Subscription[]> {
    let url_ = this.baseUrl + "/devices/{deviceId}/subscriptions";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSubscriptions(_response);
      });
  }

  protected processGetSubscriptions(
    response: Response
  ): Promise<Subscription[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(Subscription.fromJS(item));
        }
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Info about a subscription on a device
   * @deviceId The id (UUID) of the device.
   * @subscriptionId The id (UUID) of the subscription.
   * @return Expected response to a valid request.
   */
  getSubscription(
    deviceId: string,
    subscriptionId: string
  ): Promise<Subscription> {
    let url_ =
      this.baseUrl + "/devices/{deviceId}/subscriptions/{subscriptionId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    if (subscriptionId === undefined || subscriptionId === null)
      throw new Error("The parameter 'subscriptionId' must be defined.");
    url_ = url_.replace(
      "{subscriptionId}",
      encodeURIComponent("" + subscriptionId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processGetSubscription(_response);
      });
  }

  protected processGetSubscription(response: Response): Promise<Subscription> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200
          ? Subscription.fromJS(resultData200)
          : new Subscription();
        return result200;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Delete a Subscription
   * @deviceId The id (UUID) of the device.
   * @subscriptionId The id (UUID) of the subscription.
   * @return Expected response to a valid request.
   */
  deleteSubscription(deviceId: string, subscriptionId: string): Promise<void> {
    let url_ =
      this.baseUrl + "/devices/{deviceId}/subscriptions/{subscriptionId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    if (subscriptionId === undefined || subscriptionId === null)
      throw new Error("The parameter 'subscriptionId' must be defined.");
    url_ = url_.replace(
      "{subscriptionId}",
      encodeURIComponent("" + subscriptionId)
    );
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "DELETE",
      headers: {
        "Content-Type": "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processDeleteSubscription(_response);
      });
  }

  protected processDeleteSubscription(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then(_responseText => {
        return;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Create a new location for a device
   * @deviceId The id (UUID) of the device.
   * @location Location to create for a device.
   * @return Expected response to a valid request.
   */
  createLocation(deviceId: string, location: Location): Promise<Location> {
    let url_ = this.baseUrl + "/devices/{deviceId}/locations";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(location);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processCreateLocation(_response);
      });
  }

  protected processCreateLocation(response: Response): Promise<Location> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? Location.fromJS(resultData201)
          : new Location();
        return result201;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }

  /**
   * Trigger the proximity event between a device and a ranged BLE iBeacon
   * @deviceId The id (UUID) of the device.
   * @proximityEvent The proximity event to be created for the device.
   * @return Representation of the newly created proximity event for the device.
   */
  triggerProximityEvents(
    deviceId: string,
    proximityEvent: ProximityEvent
  ): Promise<ProximityEvent> {
    let url_ = this.baseUrl + "/devices/{deviceId}/proximityEvents";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(proximityEvent);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      }
    };

    return this.transformOptions(options_)
      .then(transformedOptions_ => {
        return this.http.fetch(url_, transformedOptions_);
      })
      .then((_response: Response) => {
        return this.processTriggerProximityEvents(_response);
      });
  }

  protected processTriggerProximityEvents(
    response: Response
  ): Promise<ProximityEvent> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 201) {
      return response.text().then(_responseText => {
        let result201: any = null;
        let resultData201 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = resultData201
          ? ProximityEvent.fromJS(resultData201)
          : new ProximityEvent();
        return result201;
      });
    } else {
      return response.text().then(_responseText => {
        let result: any = null;
        let resultData =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result = resultData ? APIError.fromJS(resultData) : <any>null;
        return throwException(
          "A server error occurred.",
          status,
          _responseText,
          _headers,
          result
        );
      });
    }
  }
}

/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
export enum DeviceType {
  MobileDevice = <any>"MobileDevice",
  PinDevice = <any>"PinDevice",
  IBeaconDevice = <any>"IBeaconDevice"
}

/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
export class Device implements IDevice {
  /** The id (UUID) of the device. */
  id?: string;
  /** The timestamp of the device's creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The timestamp of the device's creation in seconds since Jan 01 1970 (UTC).
   */
  updatedAt?: number;
  /** Optional device groups, one device can belong to multiple groups, grops are string that can be max 25 characters long and contains letters numbers or underscores */
  group?: string[];
  /** The name of the device. */
  name?: string;

  protected _discriminator: string;

  constructor(data?: IDevice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.name = "";
    }
    this._discriminator = "Device";
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.createdAt = data["createdAt"];
      this.updatedAt = data["updatedAt"];
      if (data["group"] && data["group"].constructor === Array) {
        this.group = [];
        for (let item of data["group"]) this.group.push(item);
      }
      this.name = data["name"] !== undefined ? data["name"] : "";
    }
  }

  static fromJS(data: any): Device {
    data = typeof data === "object" ? data : {};
    if (data["deviceType"] === "MobileDevice") {
      let result = new MobileDevice();
      result.init(data);
      return result;
    }
    if (data["deviceType"] === "PinDevice") {
      let result = new PinDevice();
      result.init(data);
      return result;
    }
    if (data["deviceType"] === "IBeaconDevice") {
      let result = new IBeaconDevice();
      result.init(data);
      return result;
    }
    let result = new Device();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["deviceType"] = this._discriminator;
    data["id"] = this.id;
    data["createdAt"] = this.createdAt;
    data["updatedAt"] = this.updatedAt;
    if (this.group && this.group.constructor === Array) {
      data["group"] = [];
      for (let item of this.group) data["group"].push(item);
    }
    data["name"] = this.name;
    return data;
  }
}

/** A device might be either virtual like a pin device or physical like a mobile phone or iBeacon device. */
export interface IDevice {
  /** The id (UUID) of the device. */
  id?: string;
  /** The timestamp of the device's creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The timestamp of the device's creation in seconds since Jan 01 1970 (UTC).
   */
  updatedAt?: number;
  /** Optional device groups, one device can belong to multiple groups, grops are string that can be max 25 characters long and contains letters numbers or underscores */
  group?: string[];
  /** The name of the device. */
  name?: string;
}

/** Describes update of device, it allows to change name of device and device token (only in case of mobile devices) */
export class DeviceUpdate implements IDeviceUpdate {
  /** New device name (optional) */
  name?: string;
  /** Token used for pushing matches. The token needs to be prefixed with `apns://` or `fcm://` dependent on the device or channel the match should be pushed with */
  deviceToken?: string;

  constructor(data?: IDeviceUpdate) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.name = data["name"];
      this.deviceToken = data["deviceToken"];
    }
  }

  static fromJS(data: any): DeviceUpdate {
    data = typeof data === "object" ? data : {};
    let result = new DeviceUpdate();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["deviceToken"] = this.deviceToken;
    return data;
  }
}

/** Describes update of device, it allows to change name of device and device token (only in case of mobile devices) */
export interface IDeviceUpdate {
  /** New device name (optional) */
  name?: string;
  /** Token used for pushing matches. The token needs to be prefixed with `apns://` or `fcm://` dependent on the device or channel the match should be pushed with */
  deviceToken?: string;
}

export class IBeaconTriple implements IIBeaconTriple {
  /** The deviceId of the beacon.
   */
  deviceId?: string;
  /** The UUID of the beacon, the purpose is to distinguish iBeacons
in your network, from all other beacons in
networks outside your control.
 */
  proximityUUID?: string;
  /** Major values are intended to identify and
distinguish a group.
 */
  major?: number;
  /** Minor values are intended to identify and
distinguish an individual.
 */
  minor?: number;

  constructor(data?: IIBeaconTriple) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.deviceId = data["deviceId"];
      this.proximityUUID = data["proximityUUID"];
      this.major = data["major"];
      this.minor = data["minor"];
    }
  }

  static fromJS(data: any): IBeaconTriple {
    data = typeof data === "object" ? data : {};
    let result = new IBeaconTriple();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["deviceId"] = this.deviceId;
    data["proximityUUID"] = this.proximityUUID;
    data["major"] = this.major;
    data["minor"] = this.minor;
    return data;
  }
}

export interface IIBeaconTriple {
  /** The deviceId of the beacon.
   */
  deviceId?: string;
  /** The UUID of the beacon, the purpose is to distinguish iBeacons
in your network, from all other beacons in
networks outside your control.
 */
  proximityUUID?: string;
  /** Major values are intended to identify and
distinguish a group.
 */
  major?: number;
  /** Minor values are intended to identify and
distinguish an individual.
 */
  minor?: number;
}

export class Location implements ILocation {
  /** The timestamp of the location creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The latitude of the device in degrees, for instance
'46.5333' (Lausanne, Switzerland).
 */
  latitude: number;
  /** The longitude of the device in degrees, for instance
'6.6667' (Lausanne, Switzerland).
 */
  longitude: number;
  /** The altitude of the device in meters, for instance '495.0' (Lausanne,
Switzerland).
 */
  altitude: number;
  /** The horizontal accuracy of the location, measured on a
scale from '0.0' to '1.0', '1.0' being the most
accurate. If this value is not specified then the default
value of '1.0' is used.
 */
  horizontalAccuracy?: number;
  /** The vertical accuracy of the location, measured on a scale from '0.0'
to '1.0', '1.0' being the most accurate. If this value is not
specified then the default value of '1.0' is used.
 */
  verticalAccuracy?: number;

  constructor(data?: ILocation) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.latitude = 0;
      this.longitude = 0;
      this.altitude = 0;
      this.horizontalAccuracy = 1;
      this.verticalAccuracy = 1;
    }
  }

  init(data?: any) {
    if (data) {
      this.createdAt = data["createdAt"];
      this.latitude = data["latitude"] !== undefined ? data["latitude"] : 0;
      this.longitude = data["longitude"] !== undefined ? data["longitude"] : 0;
      this.altitude = data["altitude"] !== undefined ? data["altitude"] : 0;
      this.horizontalAccuracy =
        data["horizontalAccuracy"] !== undefined
          ? data["horizontalAccuracy"]
          : 1;
      this.verticalAccuracy =
        data["verticalAccuracy"] !== undefined ? data["verticalAccuracy"] : 1;
    }
  }

  static fromJS(data: any): Location {
    data = typeof data === "object" ? data : {};
    let result = new Location();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["createdAt"] = this.createdAt;
    data["latitude"] = this.latitude;
    data["longitude"] = this.longitude;
    data["altitude"] = this.altitude;
    data["horizontalAccuracy"] = this.horizontalAccuracy;
    data["verticalAccuracy"] = this.verticalAccuracy;
    return data;
  }
}

export interface ILocation {
  /** The timestamp of the location creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The latitude of the device in degrees, for instance
'46.5333' (Lausanne, Switzerland).
 */
  latitude: number;
  /** The longitude of the device in degrees, for instance
'6.6667' (Lausanne, Switzerland).
 */
  longitude: number;
  /** The altitude of the device in meters, for instance '495.0' (Lausanne,
Switzerland).
 */
  altitude: number;
  /** The horizontal accuracy of the location, measured on a
scale from '0.0' to '1.0', '1.0' being the most
accurate. If this value is not specified then the default
value of '1.0' is used.
 */
  horizontalAccuracy?: number;
  /** The vertical accuracy of the location, measured on a scale from '0.0'
to '1.0', '1.0' being the most accurate. If this value is not
specified then the default value of '1.0' is used.
 */
  verticalAccuracy?: number;
}

/** A publication can be seen as a JavaMessagingService (JMS) publication extended with the notion of a geographical zone. The zone is defined as circle with a center at the given location and a range around that location. */
export class Publication implements IPublication {
  /** The id (UUID) of the publication. */
  id?: string;
  /** The timestamp of the publication creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The id (UUID) of the world that contains device to attach a publication to. */
  worldId: string;
  /** The id (UUID) of the device to attach a publication to. */
  deviceId: string;
  /** The topic of the publication. This will act as a first match filter.
For a subscription to be able to match a publication they must have
the exact same topic.
 */
  topic: string;
  /** In some cases a develop might want to show the location.
   */
  location?: Location;
  /** The range of the publication in meters. This is the range around the
device holding the publication in which matches with subscriptions can
be triggered.
 */
  range: number;
  /** The duration of the publication in seconds. If set to '0' it will be instant at
the time of publication. Negative values are not allowed.
 */
  duration: number;
  /** The dictionary of key, value pairs. Allowed values are number, boolean, string and array of afformentioned types */
  properties: { [key: string]: any };

  constructor(data?: IPublication) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.properties = {};
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.createdAt = data["createdAt"];
      this.worldId = data["worldId"];
      this.deviceId = data["deviceId"];
      this.topic = data["topic"];
      this.location = data["location"]
        ? Location.fromJS(data["location"])
        : <any>undefined;
      this.range = data["range"];
      this.duration = data["duration"];
      if (data["properties"]) {
        this.properties = {};
        for (let key in data["properties"]) {
          if (data["properties"].hasOwnProperty(key))
            this.properties[key] = data["properties"][key]
              ?  data["properties"][key]
              : <any>undefined;
        }
      }
    }
  }

  static fromJS(data: any): Publication {
    data = typeof data === "object" ? data : {};
    let result = new Publication();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["createdAt"] = this.createdAt;
    data["worldId"] = this.worldId;
    data["deviceId"] = this.deviceId;
    data["topic"] = this.topic;
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    data["range"] = this.range;
    data["duration"] = this.duration;
    if (this.properties) {
      data["properties"] = {};
      for (let key in this.properties) {
        if (this.properties.hasOwnProperty(key))
          data["properties"][key] = this.properties[key];
      }
    }
    return data;
  }
}

/** A publication can be seen as a JavaMessagingService (JMS) publication extended with the notion of a geographical zone. The zone is defined as circle with a center at the given location and a range around that location. */
export interface IPublication {
  /** The id (UUID) of the publication. */
  id?: string;
  /** The timestamp of the publication creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The id (UUID) of the world that contains device to attach a publication to. */
  worldId?: string;
  /** The id (UUID) of the device to attach a publication to. */
  deviceId?: string;
  /** The topic of the publication. This will act as a first match filter.
For a subscription to be able to match a publication they must have
the exact same topic.
 */
  topic: string;
  /** In some cases a develop might want to show the location.
   */
  location?: Location;
  /** The range of the publication in meters. This is the range around the
device holding the publication in which matches with subscriptions can
be triggered.
 */
  range: number;
  /** The duration of the publication in seconds. If set to '0' it will be instant at
the time of publication. Negative values are not allowed.
 */
  duration: number;
  /** The dictionary of key, value pairs. Allowed values are number, boolean, string and array of afformentioned types */
  properties: { [key: string]: any };
}

/** A subscription can be seen as a JMS subscription extended with the notion of geographical zone. The zone again being defined as circle with a center at the given location and a range around that location. */
export class Subscription implements ISubscription {
  /** The id (UUID) of the subscription. */
  id?: string;
  /** The timestamp of the subscription creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The id (UUID) of the world that contains device to attach a subscription to. */
  worldId: string;
  /** The id (UUID) of the device to attach a subscription to. */
  deviceId: string;
  /** The topic of the subscription. This will act as a first match filter.
For a subscription to be able to match a publication they must have
the exact same topic.
 */
  topic: string;
  /** In some cases a develop might want to show the location.
   */
  location?: Location;
  /** This is an expression to filter the publications. For instance
'job='developer'' will allow matching only with publications
containing a 'job' key with a value of 'developer'.
 */
  selector: string;
  /** The range of the subscription in meters. This is the range around the
device holding the subscription in which matches with publications can
be triggered.
 */
  range: number;
  /** The duration of the subscription in seconds. If set to '0' it will be instant at
the time of subscription. Negative values are not allowed.
 */
  duration: number;
  /** The duration of the match in seconds, this describes how often you will get matches when publication and subscription are moving in each other range.
If set to '0' you will get matches every time publication or subscription in range will move.
Negative values are not allowed.
 */
  matchTTL?: number;
  /** When match will occurs,
they will be notified on these provided URI(s) address(es) in the pushers array.
 */
  pushers?: string[];

  constructor(data?: ISubscription) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.createdAt = data["createdAt"];
      this.worldId = data["worldId"];
      this.deviceId = data["deviceId"];
      this.topic = data["topic"];
      this.location = data["location"]
        ? Location.fromJS(data["location"])
        : <any>undefined;
      this.selector = data["selector"];
      this.range = data["range"];
      this.duration = data["duration"];
      this.matchTTL = data["matchTTL"];
      if (data["pushers"] && data["pushers"].constructor === Array) {
        this.pushers = [];
        for (let item of data["pushers"]) this.pushers.push(item);
      }
    }
  }

  static fromJS(data: any): Subscription {
    data = typeof data === "object" ? data : {};
    let result = new Subscription();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["createdAt"] = this.createdAt;
    data["worldId"] = this.worldId;
    data["deviceId"] = this.deviceId;
    data["topic"] = this.topic;
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    data["selector"] = this.selector;
    data["range"] = this.range;
    data["duration"] = this.duration;
    data["matchTTL"] = this.matchTTL;
    if (this.pushers && this.pushers.constructor === Array) {
      data["pushers"] = [];
      for (let item of this.pushers) data["pushers"].push(item);
    }
    return data;
  }
}

/** A subscription can be seen as a JMS subscription extended with the notion of geographical zone. The zone again being defined as circle with a center at the given location and a range around that location. */
export interface ISubscription {
  /** The id (UUID) of the subscription. */
  id?: string;
  /** The timestamp of the subscription creation in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The id (UUID) of the world that contains device to attach a subscription to. */
  worldId?: string;
  /** The id (UUID) of the device to attach a subscription to. */
  deviceId?: string;
  /** The topic of the subscription. This will act as a first match filter.
For a subscription to be able to match a publication they must have
the exact same topic.
 */
  topic: string;
  /** In some cases a develop might want to show the location.
   */
  location?: Location;
  /** This is an expression to filter the publications. For instance
'job='developer'' will allow matching only with publications
containing a 'job' key with a value of 'developer'.
 */
  selector: string;
  /** The range of the subscription in meters. This is the range around the
device holding the subscription in which matches with publications can
be triggered.
 */
  range: number;
  /** The duration of the subscription in seconds. If set to '0' it will be instant at
the time of subscription. Negative values are not allowed.
 */
  duration: number;
  /** The duration of the match in seconds, this describes how often you will get matches when publication and subscription are moving in each other range.
If set to '0' you will get matches every time publication or subscription in range will move.
Negative values are not allowed.
 */
  matchTTL?: number;
  /** When match will occurs,
they will be notified on these provided URI(s) address(es) in the pushers array.
 */
  pushers?: string[];
}

/** An object representing a match between a subscription and a publication. */
export class Match implements IMatch {
  /** The id (UUID) of the match. */
  id?: string;
  /** The timestamp of the match in seconds since Jan 01 1970 (UTC). */
  createdAt?: number;
  publication: Publication;
  subscription: Subscription;

  constructor(data?: IMatch) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.publication = new Publication();
      this.subscription = new Subscription();
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.createdAt = data["createdAt"];
      this.publication = data["publication"]
        ? Publication.fromJS(data["publication"])
        : new Publication();
      this.subscription = data["subscription"]
        ? Subscription.fromJS(data["subscription"])
        : new Subscription();
    }
  }

  static fromJS(data: any): Match {
    data = typeof data === "object" ? data : {};
    let result = new Match();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["createdAt"] = this.createdAt;
    data["publication"] = this.publication
      ? this.publication.toJSON()
      : <any>undefined;
    data["subscription"] = this.subscription
      ? this.subscription.toJSON()
      : <any>undefined;
    return data;
  }
}

/** An object representing a match between a subscription and a publication. */
export interface IMatch {
  /** The id (UUID) of the match. */
  id?: string;
  /** The timestamp of the match in seconds since Jan 01 1970 (UTC). */
  createdAt?: number;
  publication: Publication;
  subscription: Subscription;
}

export class APIError implements IAPIError {
  code: number;
  message: string;

  constructor(data?: IAPIError) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.code = data["code"];
      this.message = data["message"];
    }
  }

  static fromJS(data: any): APIError {
    data = typeof data === "object" ? data : {};
    let result = new APIError();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["code"] = this.code;
    data["message"] = this.message;
    return data;
  }
}

export interface IAPIError {
  code: number;
  message: string;
}

/** A mobile device is one that potentially moves together with its user and therefore has a geographical location associated with it. */
export class MobileDevice extends Device implements IMobileDevice {
  /** The platform of the device, this can be any string
representing the platform type, for instance 'iOS'.
 */
  platform: string;
  /** The deviceToken is the device push notification token
given to this device by the OS, either iOS or Android for
identifying the device with push notification
services.
 */
  deviceToken: string;
  location: Location;

  constructor(data?: IMobileDevice) {
    super(data);
    if (!data) {
      this.location = new Location();
    }
    this._discriminator = "MobileDevice";
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.platform = data["platform"];
      this.deviceToken = data["deviceToken"];
      this.location = data["location"]
        ? Location.fromJS(data["location"])
        : new Location();
    }
  }

  static fromJS(data: any): MobileDevice {
    data = typeof data === "object" ? data : {};
    let result = new MobileDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["platform"] = this.platform;
    data["deviceToken"] = this.deviceToken;
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

/** A mobile device is one that potentially moves together with its user and therefore has a geographical location associated with it. */
export interface IMobileDevice extends IDevice {
  /** The platform of the device, this can be any string
representing the platform type, for instance 'iOS'.
 */
  platform: string;
  /** The deviceToken is the device push notification token
given to this device by the OS, either iOS or Android for
identifying the device with push notification
services.
 */
  deviceToken: string;
  location: Location;
}

/** A pin device is one that has geographical location associated with it but is not represented by any object in the physical world. */
export class PinDevice extends Device implements IPinDevice {
  location: Location;

  constructor(data?: IPinDevice) {
    super(data);
    if (!data) {
      this.location = new Location();
    }
    this._discriminator = "PinDevice";
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.location = data["location"]
        ? Location.fromJS(data["location"])
        : new Location();
    }
  }

  static fromJS(data: any): PinDevice {
    data = typeof data === "object" ? data : {};
    let result = new PinDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    
    data = typeof data === "object" ? data : {};
  
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }
}

/** A pin device is one that has geographical location associated with it but is not represented by any object in the physical world. */
export interface IPinDevice extends IDevice {
  location: Location;
}

/** An iBeacon device represents an Apple conform iBeacon announcing its presence via Bluetooth advertising packets. */
export class IBeaconDevice extends Device implements IIBeaconDevice {
  /** The UUID of the beacon, the purpose is to distinguish iBeacons
in your network, from all other beacons in
networks outside your control.
 */
  proximityUUID: string;
  /** Major values are intended to identify and
distinguish a group.
 */
  major: number;
  /** Minor values are intended to identify and
distinguish an individual.
 */
  minor: number;

  constructor(data?: IIBeaconDevice) {
    super(data);
    this._discriminator = "IBeaconDevice";
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.proximityUUID = data["proximityUUID"];
      this.major = data["major"];
      this.minor = data["minor"];
    }
  }

  static fromJS(data: any): IBeaconDevice {
    data = typeof data === "object" ? data : {};
    let result = new IBeaconDevice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["proximityUUID"] = this.proximityUUID;
    data["major"] = this.major;
    data["minor"] = this.minor;
    super.toJSON(data);
    return data;
  }
}

/** An iBeacon device represents an Apple conform iBeacon announcing its presence via Bluetooth advertising packets. */
export interface IIBeaconDevice extends IDevice {
  /** The UUID of the beacon, the purpose is to distinguish iBeacons
in your network, from all other beacons in
networks outside your control.
 */
  proximityUUID: string;
  /** Major values are intended to identify and
distinguish a group.
 */
  major: number;
  /** Minor values are intended to identify and
distinguish an individual.
 */
  minor: number;
}

/** A proximity event is triggered to the core when a mobile device detects an iBeacon device in his Bluetooth Low Energy(BLE) range. */
export class ProximityEvent implements IProximityEvent {
  /** The id (UUID) of the proximity event. */
  id?: string;
  /** The timestamp of the proximity event in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The id (UUID) of the iBeacon to trigger a proximity event to. */
  deviceId: string;
  /** Distance between the mobile device that trigger the proximity event
and the ranged iBeacon. This distance is automatically generated by the SDK
based upon the CLProximity.
 */
  distance: number;

  constructor(data?: IProximityEvent) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.createdAt = data["createdAt"];
      this.deviceId = data["deviceId"];
      this.distance = data["distance"];
    }
  }

  static fromJS(data: any): ProximityEvent {
    data = typeof data === "object" ? data : {};
    let result = new ProximityEvent();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["createdAt"] = this.createdAt;
    data["deviceId"] = this.deviceId;
    data["distance"] = this.distance;
    return data;
  }
}

/** A proximity event is triggered to the core when a mobile device detects an iBeacon device in his Bluetooth Low Energy(BLE) range. */
export interface IProximityEvent {
  /** The id (UUID) of the proximity event. */
  id?: string;
  /** The timestamp of the proximity event in seconds since Jan 01 1970 (UTC).
   */
  createdAt?: number;
  /** The id (UUID) of the iBeacon to trigger a proximity event to. */
  deviceId: string;
  /** Distance between the mobile device that trigger the proximity event
and the ranged iBeacon. This distance is automatically generated by the SDK
based upon the CLProximity.
 */
  distance: number;
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new SwaggerException(message, status, response, headers, null);
}
